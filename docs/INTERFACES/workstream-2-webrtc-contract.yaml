# Workstream 2: WebRTC Agent Mesh Interface Contract
#
# Purpose: Define stable interface for Session 4 (SIP) integration
# Version: 1.0.0
# Last Updated: 2025-11-11
# Owner: Workstream 2 (WebRTC Agent Mesh)
# Consumer: Workstream 4 (SIP Integration)

metadata:
  workstream: 2
  title: "WebRTC Agent Mesh"
  version: "1.0.0"
  status: "complete"
  deliverables:
    - src/communication/webrtc-agent-mesh.ts
    - src/communication/webrtc-signaling-server.ts
    - tests/test_webrtc_mesh.spec.ts
    - docs/WEBRTC-SWARM-MESH.md

# Core Interface: IFAgentWebRTC Class
webrtc_datachannel_interface:
  class: IFAgentWebRTC
  module: src/communication/webrtc-agent-mesh.ts

  description: |
    WebRTC peer-to-peer agent mesh with Ed25519-signed IFMessage transport.
    Enables low-latency (<50ms) real-time communication between agents.

  constructor:
    name: IFAgentWebRTC
    params:
      - name: config
        type: IFWebRTCConfig
        required: true
        schema:
          agentId:
            type: string
            required: true
            description: Unique identifier for this agent
          privateKey:
            type: Uint8Array
            required: false
            description: Ed25519 private key (auto-generated if omitted)
          publicKey:
            type: Uint8Array
            required: false
            description: Ed25519 public key (auto-generated if omitted)
          signalingServerUrl:
            type: string
            required: false
            default: "ws://localhost:8443"
            description: WebSocket signaling server URL
          stunServers:
            type: string[]
            required: false
            default: ["stun:stun.l.google.com:19302"]
            description: STUN servers for NAT traversal
          witnessLogger:
            type: "(event: WitnessEvent) => Promise<void>"
            required: false
            description: IF.witness event logger callback

  methods:
    # Connection Management
    - name: connectToSignaling
      description: Connect to WebSocket signaling server
      params: []
      returns:
        type: Promise<void>
      throws:
        - Error: "Signaling server unreachable"
      example: |
        await agent.connectToSignaling();

    - name: createOffer
      description: Create WebRTC offer to connect to peer
      params:
        - name: peerId
          type: string
          required: true
          description: Target peer agent ID
      returns:
        type: Promise<RTCSessionDescriptionInit>
      side_effects:
        - Creates RTCPeerConnection
        - Creates RTCDataChannel
        - Logs to IF.witness
      example: |
        await agent.createOffer('agent-legal');

    - name: disconnectPeer
      description: Close connection to specific peer
      params:
        - name: peerId
          type: string
          required: true
      returns:
        type: Promise<void>
      side_effects:
        - Closes RTCPeerConnection
        - Removes DataChannel
        - Logs to IF.witness

    - name: disconnect
      description: Close all peer connections and signaling
      params: []
      returns:
        type: Promise<void>
      side_effects:
        - Closes all RTCPeerConnections
        - Disconnects from signaling server
        - Logs to IF.witness

    # Message Transmission
    - name: sendIFMessage
      description: Send IFMessage to specific peer with Ed25519 signature
      params:
        - name: peerId
          type: string
          required: true
          description: Target peer agent ID
        - name: message
          type: IFMessage
          required: true
          description: Message to send (will be auto-signed)
      returns:
        type: Promise<void>
      throws:
        - Error: "Data channel to {peerId} not open"
      side_effects:
        - Adds timestamp, sequence_num, trace_id
        - Signs message with Ed25519
        - Logs to IF.witness
      example: |
        await agent.sendIFMessage('agent-legal', {
          id: 'msg-001',
          timestamp: new Date().toISOString(),
          level: 2,
          source: 'agent-finance',
          destination: 'agent-legal',
          version: '2.1',
          payload: { claim: 'Settlement: $520M' },
          performative: 'inform'
        });

    - name: broadcastIFMessage
      description: Send IFMessage to all connected peers
      params:
        - name: message
          type: IFMessage
          required: true
      returns:
        type: Promise<void>
      side_effects:
        - Sends to all peers with open DataChannels
        - Each message independently signed
      example: |
        await agent.broadcastIFMessage({
          id: 'broadcast-001',
          level: 2,
          source: 'agent-finance',
          destination: '*',
          version: '2.1',
          payload: { announcement: 'Mesh ready' },
          performative: 'inform'
        });

    # Message Reception
    - name: onIFMessage
      type: EventHandler
      description: Register handler for incoming IFMessages
      params:
        - name: handler
          type: "(message: IFMessage) => void"
          required: true
          description: Callback invoked for each received message
      returns:
        type: void
      notes:
        - Signature already verified before handler invocation
        - Handler called for messages from all connected peers
      example: |
        agent.onIFMessage((message) => {
          console.log('Received:', message.payload);
          if (message.signature) {
            console.log('Signed by:', message.signature.public_key);
          }
        });

    - name: offIFMessage
      description: Remove message handler
      params:
        - name: handler
          type: "(message: IFMessage) => void"
          required: true
      returns:
        type: void

    # Introspection
    - name: getConnectedPeers
      description: Get list of peers with open DataChannels
      params: []
      returns:
        type: string[]
        description: Array of peer agent IDs
      example: |
        const peers = agent.getConnectedPeers();
        // ['agent-legal', 'agent-macro', 'agent-markets']

    - name: getPublicKey
      description: Get agent's Ed25519 public key (hex string)
      params: []
      returns:
        type: string
        description: 64-character hex string (32 bytes)

    - name: getAgentId
      description: Get agent ID
      params: []
      returns:
        type: string

# Data Schemas
schemas:
  IFMessage:
    description: InfraFabric message format v2.1 (with Ed25519 signature)
    required_fields:
      - id
      - timestamp
      - level
      - source
      - destination
      - version
      - payload
    optional_fields:
      - traceId
      - performative
      - conversation_id
      - sequence_num
      - citation_ids
      - signature
    example:
      id: "msg-001"
      timestamp: "2025-11-11T14:32:17.234Z"
      level: 2
      source: "agent-finance"
      destination: "agent-legal"
      traceId: "a2f9c3b8d1e5"
      version: "2.1"
      payload:
        claim: "Epic Games settlement: $520M"
        evidence: ["SEC-10K-2023:pg14"]
      performative: "inform"
      conversation_id: "epic-2025-11-10-xyz"
      sequence_num: 42
      citation_ids: ["cit:9f2b3a1e"]
      signature:
        algorithm: "ed25519"
        public_key: "3a7d2f8c1b9e7d6a4f3e2c1b0a9d8e7f..."
        signature_bytes: "m8QKz5X3jP2nQ4rK9sL7vT6uY..."
        signed_fields: ["id", "timestamp", "level", "source", "destination", "payload"]

  WitnessEvent:
    description: IF.witness logging event
    required_fields:
      - event
      - agent_id
      - trace_id
      - timestamp
    optional_fields:
      - peer_id
      - sdp_hash
      - ice_candidate
      - metadata
    example:
      event: "webrtc_offer_created"
      agent_id: "agent-finance"
      peer_id: "agent-legal"
      sdp_hash: "5a3d2f8c1b9e7d6a"
      trace_id: "a2f9c3b8d1e5"
      timestamp: "2025-11-11T14:30:00.000Z"
      metadata:
        connection_state: "connecting"

# Test Fixtures (for Session 4 integration tests)
test_fixtures:
  - name: valid_ifmessage_escalate.json
    description: Valid IFMessage for escalation scenario
    path: tests/fixtures/valid_ifmessage_escalate.json
    content:
      id: "escalate-001"
      timestamp: "2025-11-11T15:00:00.000Z"
      level: 2
      source: "agent-finance"
      destination: "agent-legal"
      version: "2.1"
      payload:
        performative: "request"
        request_type: "escalate"
        evidence_needed: true
        expert_domain: "antitrust_law"
      performative: "request"
      conversation_id: "epic-escalation-001"

  - name: valid_sdp_offer.json
    description: Valid SDP offer for testing
    path: tests/fixtures/valid_sdp_offer.json
    content:
      type: "offer"
      sdp: "v=0\r\no=- 4611731400430051336 2 IN IP4 127.0.0.1\r\ns=-\r\n..."

  - name: signed_message_with_citation.json
    description: IFMessage with Ed25519 signature and citation
    path: tests/fixtures/signed_message_with_citation.json
    content:
      id: "signed-001"
      timestamp: "2025-11-11T15:05:00.000Z"
      level: 2
      source: "agent-legal"
      destination: "agent-finance"
      version: "2.1"
      payload:
        claim: "Settlement confirmed by SEC filing"
        evidence_file: "data/sec-10k-2024.pdf"
      performative: "inform"
      citation_ids: ["if://citation/9f2b3a1e-4d8a-4c7d"]
      signature:
        algorithm: "ed25519"
        public_key: "3a7d2f8c1b9e7d6a4f3e2c1b0a9d8e7f6c5b4a3d2e1f0a9b8c7d6e5f4a3b2c1d"
        signature_bytes: "m8QKz5X3jP2nQ4rK9sL7vT6uY5wZ8xA1bC3dE4fG6hH7iJ9kL0mN2oP4qR5sT7uV"
        signed_fields: ["id", "timestamp", "level", "source", "destination", "payload", "citation_ids"]

# Session 4 Integration Guide
session_4_handoff:
  description: |
    Session 4 (SIP Integration) will use WebRTC DataChannel to share evidence
    during external expert calls.

  use_case: |
    When agent needs to call external expert via SIP, it can simultaneously
    share evidence files with peer agents via WebRTC DataChannel.

  integration_steps:
    1. Import IFAgentWebRTC class
    2. Create instance and connect to signaling
    3. Establish peer connections to relevant agents
    4. During SIP call, send evidence via sendIFMessage()
    5. Receive responses via onIFMessage() handler

  example_flow: |
    // Session 4: SIP Integration
    import { IFAgentWebRTC } from './src/communication/webrtc-agent-mesh';

    // 1. Initialize WebRTC agent
    const webrtcAgent = new IFAgentWebRTC({
      agentId: 'agent-legal',
      signalingServerUrl: 'ws://localhost:8443'
    });

    await webrtcAgent.connectToSignaling();
    await webrtcAgent.createOffer('agent-finance'); // Connect to Finance agent

    // 2. During SIP call to external expert
    sipCall.on('expert-requests-evidence', async (expertRequest) => {
      // Send evidence to peer agents via DataChannel
      await webrtcAgent.sendIFMessage('agent-finance', {
        id: 'evidence-share-001',
        level: 2,
        source: 'agent-legal',
        destination: 'agent-finance',
        version: '2.1',
        payload: {
          performative: 'inform',
          evidence_type: 'expert_opinion',
          expert_name: expertRequest.name,
          file_path: '/evidence/expert-antitrust-analysis.pdf'
        },
        performative: 'inform'
      });
    });

    // 3. Receive peer feedback
    webrtcAgent.onIFMessage((message) => {
      if (message.performative === 'agree') {
        console.log('Finance agent approved evidence sharing');
        // Proceed with sharing to expert via SIP
      }
    });

  contract_guarantees:
    - IFAgentWebRTC interface remains stable (no breaking changes)
    - IFMessage v2.1 schema supported
    - Ed25519 signatures on all messages
    - All events logged to IF.witness
    - Latency < 50ms for peer-to-peer messages

# Performance Characteristics
performance:
  latency:
    peer_to_peer_message: "<50ms (p95)"
    ed25519_signing: "~0.3ms"
    ed25519_verification: "~0.5ms"
  throughput:
    single_datachannel: "~5000 msg/sec (small messages)"
    bandwidth: "~500 KB/s sustained, ~5 MB/s burst"
  resource_usage:
    memory_per_agent: "~50 MB base + 5 MB per peer"
    cpu_idle: "<1%"
    cpu_active_1000msg_s: "~5%"

# Security Guarantees
security:
  message_integrity:
    algorithm: "Ed25519"
    security_level: "128-bit (equivalent to 3072-bit RSA)"
    signed_fields: ["id", "timestamp", "level", "source", "destination", "payload", "performative", "conversation_id", "sequence_num"]

  attack_resistance:
    forgery: "Computationally infeasible (2^128 operations)"
    impersonation: "Requires private key (cannot derive from public key)"
    replay: "Protected by monotonically increasing sequence_num"
    mitm: "Signaling visible but cannot forge Ed25519 signatures"

  if_witness_logging:
    - webrtc_offer_created
    - webrtc_answer_created
    - ice_candidate_sent
    - datachannel_open
    - ifmessage_sent
    - ifmessage_received
    - peer_disconnected

# Dependencies
dependencies:
  runtime:
    - ws: "^8.16.0"
    - "@noble/ed25519": "^2.0.0"
  dev:
    - typescript: "^5.3.3"
    - "@types/node": "^20.11.0"
    - "@types/ws": "^8.5.10"
    - jest: "^29.7.0"

# Known Limitations
limitations:
  - WebRTC requires STUN/TURN servers for NAT traversal
  - Signaling server is single point of failure (needs HA setup for production)
  - DataChannel limited to ~16 MB messages (use chunking for larger files)
  - Browser-based agents need different WebRTC polyfill (not included)

# Future Enhancements
roadmap:
  - Add payload encryption (currently only signed, not encrypted)
  - Implement message queuing for offline delivery
  - Add TURN server support for restrictive NATs
  - Create metrics dashboard for mesh visualization
  - Integrate with DDS/RTPS for hybrid transport

# Contact & Support
maintainer:
  team: "InfraFabric Workstream 2"
  documentation: "docs/WEBRTC-SWARM-MESH.md"
  tests: "tests/test_webrtc_mesh.spec.ts"
  issues: "https://github.com/dannystocker/infrafabric/issues"

version_history:
  - version: "1.0.0"
    date: "2025-11-11"
    changes:
      - Initial implementation
      - IFAgentWebRTC class with Ed25519 signatures
      - WebSocket signaling server
      - Full test suite
      - Complete documentation
