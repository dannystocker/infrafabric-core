/**
 * TURN Server Deployment Script for IF.swarm (Staging)
 *
 * Purpose:
 * - Deploy Coturn TURN server for WebRTC relay fallback
 * - Generate configuration files with IF.witness logging
 * - Health checks and automated recovery
 * - Secure credential management
 *
 * Philosophy:
 * - IF.ground: Reproducible deployment (Docker-based)
 * - IF.witness: All deployment events logged
 * - IF.TTT: Transparent deployment process
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { writeFile, readFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

const execAsync = promisify(exec);

/**
 * TURN Server Configuration
 */
export interface TURNConfig {
  // Network
  listeningPort: number;
  tlsListeningPort: number;
  minPort: number;
  maxPort: number;
  realm: string;
  externalIp?: string;

  // Authentication
  staticAuthSecret?: string;

  // Long-term credentials
  users?: Array<{
    username: string;
    password: string;
  }>;

  // Logging
  verbose: boolean;
  logFile: string;

  // Security
  fingerprintAlgorithm: 'sha-256' | 'sha-1';
  noTlsv1: boolean;
  noTlsv1_1: boolean;
  noTlsv1_2: boolean;

  // SSL/TLS
  certFile?: string;
  keyFile?: string;
}

/**
 * Deployment Configuration
 */
export interface DeploymentConfig {
  environment: 'staging' | 'production';
  dockerImage: string;
  containerName: string;
  turnConfig: TURNConfig;
  healthCheckInterval: number; // ms
  autoRestart: boolean;
  witnessLogger?: (event: WitnessEvent) => Promise<void>;
}

/**
 * IF.witness Event
 */
interface WitnessEvent {
  event: string;
  timestamp: string;
  metadata?: Record<string, unknown>;
}

/**
 * TURN Server Deployment Manager
 */
export class TURNDeployment {
  private config: DeploymentConfig;
  private healthCheckTimer?: NodeJS.Timeout;
  private witnessLogger?: (event: WitnessEvent) => Promise<void>;

  constructor(config: DeploymentConfig) {
    this.config = config;
    this.witnessLogger = config.witnessLogger;
  }

  /**
   * Deploy TURN server
   */
  async deploy(): Promise<void> {
    await this.logToWitness({
      event: 'turn_deployment_started',
      timestamp: new Date().toISOString(),
      metadata: {
        environment: this.config.environment,
        containerName: this.config.containerName
      }
    });

    try {
      // 1. Generate configuration file
      await this.generateCoturnConfig();

      // 2. Stop existing container if running
      await this.stopContainer();

      // 3. Pull Docker image
      await this.pullDockerImage();

      // 4. Start TURN server container
      await this.startContainer();

      // 5. Verify deployment
      await this.verifyDeployment();

      // 6. Start health checks
      if (this.config.autoRestart) {
        this.startHealthChecks();
      }

      await this.logToWitness({
        event: 'turn_deployment_completed',
        timestamp: new Date().toISOString(),
        metadata: {
          containerName: this.config.containerName,
          listeningPort: this.config.turnConfig.listeningPort
        }
      });

      console.log(`✓ TURN server deployed successfully`);
      console.log(`  Container: ${this.config.containerName}`);
      console.log(`  Port: ${this.config.turnConfig.listeningPort}`);
      console.log(`  TLS Port: ${this.config.turnConfig.tlsListeningPort}`);
    } catch (error) {
      await this.logToWitness({
        event: 'turn_deployment_failed',
        timestamp: new Date().toISOString(),
        metadata: {
          error: String(error)
        }
      });
      throw error;
    }
  }

  /**
   * Generate Coturn configuration file
   */
  private async generateCoturnConfig(): Promise<void> {
    const cfg = this.config.turnConfig;

    const configLines = [
      '# Coturn Configuration for IF.swarm',
      '# Generated by turn-staging.ts',
      `# Environment: ${this.config.environment}`,
      `# Generated: ${new Date().toISOString()}`,
      '',
      '# Listening ports',
      `listening-port=${cfg.listeningPort}`,
      `tls-listening-port=${cfg.tlsListeningPort}`,
      '',
      '# Relay ports range',
      `min-port=${cfg.minPort}`,
      `max-port=${cfg.maxPort}`,
      '',
      '# Realm',
      `realm=${cfg.realm}`,
      '',
    ];

    // External IP
    if (cfg.externalIp) {
      configLines.push(`external-ip=${cfg.externalIp}`);
      configLines.push('');
    }

    // Authentication
    if (cfg.staticAuthSecret) {
      configLines.push('# Static auth secret (time-limited credentials)');
      configLines.push('use-auth-secret');
      configLines.push(`static-auth-secret=${cfg.staticAuthSecret}`);
      configLines.push('');
    } else if (cfg.users && cfg.users.length > 0) {
      configLines.push('# Long-term credentials');
      configLines.push('lt-cred-mech');
      for (const user of cfg.users) {
        configLines.push(`user=${user.username}:${user.password}`);
      }
      configLines.push('');
    }

    // Logging
    configLines.push('# Logging');
    if (cfg.verbose) {
      configLines.push('verbose');
    }
    configLines.push(`log-file=${cfg.logFile}`);
    configLines.push('');

    // Security
    configLines.push('# Security');
    configLines.push(`fingerprint`);
    if (cfg.noTlsv1) configLines.push('no-tlsv1');
    if (cfg.noTlsv1_1) configLines.push('no-tlsv1_1');
    if (cfg.noTlsv1_2) configLines.push('no-tlsv1_2');
    configLines.push('');

    // SSL/TLS certificates
    if (cfg.certFile && cfg.keyFile) {
      configLines.push('# SSL/TLS');
      configLines.push(`cert=${cfg.certFile}`);
      configLines.push(`pkey=${cfg.keyFile}`);
      configLines.push('');
    }

    // Additional security settings
    configLines.push('# Additional security');
    configLines.push('no-multicast-peers');
    configLines.push('no-cli');
    configLines.push('no-stdout-log');
    configLines.push('');

    // Performance
    configLines.push('# Performance');
    configLines.push('max-bps=1000000');
    configLines.push('bps-capacity=0');
    configLines.push('');

    const configContent = configLines.join('\n');

    // Write to deploy/staging directory
    const configDir = path.join(process.cwd(), 'deploy', 'staging');
    if (!existsSync(configDir)) {
      await mkdir(configDir, { recursive: true });
    }

    const configPath = path.join(configDir, 'coturn.conf');
    await writeFile(configPath, configContent);

    console.log(`✓ Generated Coturn configuration: ${configPath}`);
  }

  /**
   * Pull Docker image
   */
  private async pullDockerImage(): Promise<void> {
    console.log(`Pulling Docker image: ${this.config.dockerImage}...`);

    try {
      const { stdout, stderr } = await execAsync(`docker pull ${this.config.dockerImage}`);
      console.log(stdout);
      if (stderr) console.error(stderr);
    } catch (error) {
      throw new Error(`Failed to pull Docker image: ${error}`);
    }
  }

  /**
   * Stop existing container
   */
  private async stopContainer(): Promise<void> {
    try {
      const { stdout } = await execAsync(`docker ps -a --filter name=${this.config.containerName} --format "{{.Names}}"`);

      if (stdout.trim() === this.config.containerName) {
        console.log(`Stopping existing container: ${this.config.containerName}...`);
        await execAsync(`docker stop ${this.config.containerName}`);
        await execAsync(`docker rm ${this.config.containerName}`);
        console.log(`✓ Stopped and removed existing container`);
      }
    } catch (error) {
      // Container doesn't exist, continue
    }
  }

  /**
   * Start TURN server container
   */
  private async startContainer(): Promise<void> {
    const cfg = this.config.turnConfig;
    const configPath = path.join(process.cwd(), 'deploy', 'staging', 'coturn.conf');

    // Docker run command
    const dockerCmd = [
      'docker run -d',
      `--name ${this.config.containerName}`,
      '--network host',
      `--restart ${this.config.autoRestart ? 'unless-stopped' : 'no'}`,
      `-v ${configPath}:/etc/coturn/turnserver.conf:ro`,
      `-v ${path.dirname(cfg.logFile)}:${path.dirname(cfg.logFile)}`,
      this.config.dockerImage,
      '-c /etc/coturn/turnserver.conf'
    ].join(' ');

    console.log(`Starting TURN server container...`);
    console.log(`Command: ${dockerCmd}`);

    try {
      const { stdout, stderr } = await execAsync(dockerCmd);
      console.log(stdout);
      if (stderr) console.error(stderr);
      console.log(`✓ Container started: ${this.config.containerName}`);
    } catch (error) {
      throw new Error(`Failed to start container: ${error}`);
    }
  }

  /**
   * Verify deployment
   */
  private async verifyDeployment(): Promise<void> {
    console.log(`Verifying deployment...`);

    // Wait for container to start
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Check container status
    try {
      const { stdout } = await execAsync(`docker ps --filter name=${this.config.containerName} --format "{{.Status}}"`);

      if (!stdout.includes('Up')) {
        throw new Error(`Container not running: ${stdout}`);
      }

      console.log(`✓ Container is running`);
    } catch (error) {
      throw new Error(`Deployment verification failed: ${error}`);
    }

    // Check logs
    try {
      const { stdout } = await execAsync(`docker logs ${this.config.containerName} 2>&1 | tail -20`);
      console.log('Container logs:');
      console.log(stdout);
    } catch (error) {
      console.error(`Failed to retrieve logs: ${error}`);
    }
  }

  /**
   * Start health checks
   */
  private startHealthChecks(): void {
    this.healthCheckTimer = setInterval(async () => {
      await this.performHealthCheck();
    }, this.config.healthCheckInterval);

    console.log(`✓ Health checks started (interval: ${this.config.healthCheckInterval}ms)`);
  }

  /**
   * Perform health check
   */
  private async performHealthCheck(): Promise<void> {
    try {
      const { stdout } = await execAsync(`docker ps --filter name=${this.config.containerName} --format "{{.Status}}"`);

      if (!stdout.includes('Up')) {
        await this.logToWitness({
          event: 'turn_health_check_failed',
          timestamp: new Date().toISOString(),
          metadata: {
            containerName: this.config.containerName,
            status: stdout.trim()
          }
        });

        // Restart container
        if (this.config.autoRestart) {
          console.log(`Container unhealthy, restarting...`);
          await this.stopContainer();
          await this.startContainer();

          await this.logToWitness({
            event: 'turn_auto_restarted',
            timestamp: new Date().toISOString(),
            metadata: {
              containerName: this.config.containerName
            }
          });
        }
      }
    } catch (error) {
      console.error(`Health check error: ${error}`);
    }
  }

  /**
   * Stop health checks
   */
  stopHealthChecks(): void {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = undefined;
      console.log('✓ Health checks stopped');
    }
  }

  /**
   * Stop TURN server
   */
  async stop(): Promise<void> {
    this.stopHealthChecks();
    await this.stopContainer();

    await this.logToWitness({
      event: 'turn_stopped',
      timestamp: new Date().toISOString(),
      metadata: {
        containerName: this.config.containerName
      }
    });
  }

  /**
   * Get container status
   */
  async getStatus(): Promise<{
    running: boolean;
    status: string;
    logs: string;
  }> {
    try {
      const { stdout: status } = await execAsync(`docker ps -a --filter name=${this.config.containerName} --format "{{.Status}}"`);
      const { stdout: logs } = await execAsync(`docker logs ${this.config.containerName} 2>&1 | tail -50`);

      return {
        running: status.includes('Up'),
        status: status.trim(),
        logs: logs.trim()
      };
    } catch (error) {
      return {
        running: false,
        status: 'Not found',
        logs: ''
      };
    }
  }

  /**
   * Log to IF.witness
   */
  private async logToWitness(event: WitnessEvent): Promise<void> {
    if (this.witnessLogger) {
      await this.witnessLogger(event);
    } else {
      console.log(`[IF.witness] ${event.event}:`, event.metadata || {});
    }
  }

  /**
   * Generate random auth secret
   */
  static generateAuthSecret(): string {
    return crypto.randomBytes(32).toString('base64');
  }

  /**
   * Generate random username/password
   */
  static generateCredentials(): { username: string; password: string } {
    return {
      username: `ifswarm_${crypto.randomBytes(8).toString('hex')}`,
      password: crypto.randomBytes(32).toString('base64')
    };
  }
}

/**
 * Main entry point (if run directly)
 */
if (import.meta.url === `file://${process.argv[1]}`) {
  // Default staging configuration
  const stagingConfig: DeploymentConfig = {
    environment: 'staging',
    dockerImage: 'coturn/coturn:latest',
    containerName: 'ifswarm-turn-staging',
    healthCheckInterval: 30000, // 30 seconds
    autoRestart: true,
    turnConfig: {
      listeningPort: 3478,
      tlsListeningPort: 5349,
      minPort: 49152,
      maxPort: 65535,
      realm: 'ifswarm.staging',
      externalIp: process.env.EXTERNAL_IP,
      staticAuthSecret: process.env.TURN_AUTH_SECRET || TURNDeployment.generateAuthSecret(),
      verbose: true,
      logFile: '/var/log/coturn/turn.log',
      fingerprintAlgorithm: 'sha-256',
      noTlsv1: true,
      noTlsv1_1: true,
      noTlsv1_2: false,
      certFile: process.env.TLS_CERT_FILE,
      keyFile: process.env.TLS_KEY_FILE
    }
  };

  const deployment = new TURNDeployment(stagingConfig);

  deployment.deploy().catch((error) => {
    console.error('Deployment failed:', error);
    process.exit(1);
  });

  // Graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\nShutting down...');
    await deployment.stop();
    process.exit(0);
  });

  process.on('SIGTERM', async () => {
    console.log('\nShutting down...');
    await deployment.stop();
    process.exit(0);
  });
}
